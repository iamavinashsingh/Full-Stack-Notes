# JavaScript Objects â€” Quick Notes

## 1. What is an Object?

* An object is a **collection of keyâ€“value pairs**.
* Keys are **strings or Symbols**; values can be **any type** (number, string, array, object, etc.).

```js
const person = {
  name: "Alice",
  age: 30,
  isStudent: true
};
```

## 2. CRUD Operations

### A. Create

```js
const user = { username: "js_dev", loginCount: 57 };
```

### B. Read (Access)

* **Dot Notation:** `user.username`
* **Bracket Notation:** `user["loginCount"]`
* Use bracket notation when key has special characters or comes from a variable.

### C. Update/Add

```js
user.isPremium = true;
user.username = "pro_dev";
```

### D. Delete

```js
delete user.isPremium;
```

---

## 3. Methods & `this`

* A function inside an object = **method**.
* `this` refers to the **object itself**.

```js
const user = {
  name: "Alice",
  greet() { console.log(`Hi, I'm ${this.name}`); }
};
user.greet();
```

---

## 4. Looping Through Objects

### A. `for...in`

Iterates keys, including prototype chain (avoid).

```js
for (const key in obj) console.log(key, obj[key]);
```

### B. Modern Methods

```js
Object.keys(obj);   // [keys]
Object.values(obj); // [values]
Object.entries(obj);// [[key,value]]

for (const [k,v] of Object.entries(obj)) console.log(k,v);
```

âœ… Safer & cleaner than `for...in`.

---

## 5. Reference Type

Objects store **references**, not copies.

```js
let a = {x:1}; let b=a; b.x=2; // a.x â†’ 2
```

### Shallow Copy

```js
const copy = {...a}; // or Object.assign({}, a)
```

### Deep Copy

```js
const clone = structuredClone(a);
```

* Handles nested objects & arrays.
* âŒ Cannot clone functions or DOM nodes.

---

## 6. Destructuring

### Object Destructuring

```js
const user = {name:"Alice", email:"a@x.com", profile:{isAdmin:true}};
const {name, email} = user;
const {profile:{isAdmin}} = user;
```

### Array Destructuring

```js
const [first, second] = [10,20,30];
```

---

## 7. Symbols

* Unique, hidden keys for objects.

```js
const id = Symbol("id");
const user = { name: "Alice", [id]: 123 };
```

* Symbol keys are **not** shown in `for...in` or `Object.keys()`.
* Use `Object.getOwnPropertySymbols(obj)` to access them.

---

## 8. Summary Table

| Method                         | Use                 | Safe | Notes                    |
| ------------------------------ | ------------------- | ---- | ------------------------ |
| `for...in`                     | Iterate keys        | âŒ    | Includes prototype props |
| `Object.keys`                  | Get keys            | âœ…    | Own props only           |
| `Object.values`                | Get values          | âœ…    | Own props only           |
| `Object.entries`               | Keys + values       | âœ…    | Best modern option       |
| `structuredClone()`            | Deep copy           | âœ…    | Built-in & fast          |
| `JSON.parse(JSON.stringify())` | Deep copy (simple)  | âš ï¸   | Loses functions          |
| `_.cloneDeep()`                | Deep copy (complex) | âœ…    | Requires lodash          |

---

**Quick Tip:** Always prefer `Object.entries()` for looping and `structuredClone()` for safe deep copying.

---
# JavaScript Functions â€” Quick Notes

## ğŸ§© Part 1: The Core Concept â€” What is a Function?

**A function** is a reusable â€œcode machineâ€ or â€œrecipe.â€ It performs a task when called.

**Analogy:**

* Function = Recipe ğŸ
* Parameters = Ingredients ğŸ¥ª
* Return Value = Finished Dish ğŸ½ï¸

### ğŸ§  Why Functions?

**DRY Principle (Donâ€™t Repeat Yourself)** â€” Write once, reuse multiple times.

### ğŸ”¹ Core Parts

1. **Declaration** â€” Define the function.
2. **Calling** â€” Use the function.
3. **Parameters / Return Value** â€” Input and output.

### Example:

```js
function greet(name) {
  const message = `Hello, ${name}!`;
  return message;
}

console.log(greet("Alice")); // Hello, Alice!
```

**Parameter:** Placeholder inside function â†’ `name`
**Argument:** Actual value passed â†’ `"Alice"`
**Return Value:** Sent back using `return`

---

## ğŸ§± Part 2: Different Ways to Create Functions

### A. Function Declaration

```js
function add(a, b) {
  return a + b;
}
console.log(add(2, 3)); // 5 âœ… Works before definition (hoisted)
```

* **Hoisted** â†’ Can be used before defined.

### B. Function Expression

```js
const subtract = function(a, b) {
  return a - b;
};
console.log(subtract(10, 5)); // 5
```

* **Not hoisted** â†’ Must be defined before use.

### C. Arrow Function (ES6)

```js
const multiply = (a, b) => a * b;
const square = x => x * x;
```

**Implicit Return:** No `{}` or `return` needed if single expression.

**Returning Objects:** Use parentheses.

```js
const createUser = name => ({ name });
```

---

## âš™ï¸ Part 3: Advanced Parameter Concepts

### A. Default Parameters (ES6)

```js
function greet(name = "Guest") {
  console.log(`Hello, ${name}!`);
}
greet(); // Hello, Guest!
```

### B. Rest Parameters (...)

```js
function sumAll(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}
console.log(sumAll(1, 2, 3, 4)); // 10
```

Collects multiple arguments into an array.

---

## ğŸŒ Part 4: Scope â€” Where Do Variables Live?

```js
let globalVar = "Global";
function example() {
  let localVar = "Local";
  console.log(globalVar); // âœ…
  console.log(localVar);  // âœ…
}
example();
// console.log(localVar); âŒ Error
```

**Global Scope:** Accessible everywhere.
**Function Scope:** Exists only inside the function.

---

## ğŸ§° Rest vs Spread â€” Same Syntax, Opposite Meaning

| Concept    | Action | Description                     |
| ---------- | ------ | ------------------------------- |
| **Spread** | Unpack | Break apart arrays/objects      |
| **Rest**   | Pack   | Gather multiple values into one |

### ğŸŸ¢ Spread Examples

```js
const arr = [1, 2, 3];
console.log(...arr); // 1 2 3

const copy = [...arr]; // Copy array
const combined = [...arr, 4, 5]; // Merge arrays

const person = { name: "Alice", age: 25 };
const updated = { ...person, city: "NYC" }; // Merge objects
```

### ğŸ”µ Rest Examples

```js
function sum(...nums) {
  return nums.reduce((a, b) => a + b);
}
console.log(sum(1,2,3)); // 6

const [first, ...rest] = [1,2,3,4];
console.log(rest); // [3,4]

const { name, ...otherInfo } = { name:"Alice", age:25, city:"NYC" };
console.log(otherInfo); // {age:25, city:"NYC"}
```

### ğŸ§  Quick Rule

* **RIGHT side = Spread** â†’ expands.
* **LEFT side = Rest** â†’ collects.

---

## âš¡ Arrow Functions In-Depth

### 1. Why Use Them?

* Shorter syntax.
* Fixes confusing `this` behavior.

### 2. Syntax Evolution

```js
// Traditional
const add = function(a, b) { return a + b; };

// Arrow
const add = (a, b) => a + b;

// Single param
const square = x => x * x;

// Zero params
const sayHi = () => "Hi!";
```

### 3. Returning Objects

```js
const makeUser = name => ({ name });
```

---

## ğŸ” Callback Functions

A **callback function** is passed into another function to be executed later.

**Analogy:** Ordering a pizza ğŸ•

* You order (call main function).
* Leave your phone number (callback function).
* They call you when ready (execute callback).

### Example

```js
function pickUpPizza() {
  console.log("Pizza is ready! ğŸ•");
}

function orderPizza(callback) {
  console.log("Placing the pizza order...");
  console.log("Pizza is cooked!");
  callback(); // Calls the function you passed
}

orderPizza(pickUpPizza);
console.log("I'm at home coding while pizza cooks.");
```

**Output:**

```
Placing the pizza order...
Pizza is cooked!
Pizza is ready! ğŸ•
```

---

### âœ… Quick Summary

| Concept        | Meaning                  | Example                      |
| -------------- | ------------------------ | ---------------------------- |
| Function       | Reusable block           | `function greet(){}`         |
| Expression     | Stored in var            | `const greet = function(){}` |
| Arrow Function | Short syntax             | `const greet = () => {}`     |
| Default Param  | Fallback value           | `(name = "Guest")`           |
| Rest Param     | Collect args             | `(...args)`                  |
| Spread         | Expand array/object      | `(...arr)`                   |
| Callback       | Function inside function | `orderPizza(pickUpPizza)`    |

---

# JavaScript Engine & Execution Flow â€” The Complete Picture

## ğŸ’¡ The Fundamental Problem: Computers Are Not Smart

* The CPU doesnâ€™t understand JavaScript â€” it only understands **Machine Code (1s and 0s)**.
* JavaScript must be **translated into machine instructions** â€” this is done by the **JavaScript Engine**.

## âš™ï¸ The JavaScript Engine

* A program that **reads, compiles, and executes** JS code.
* The most popular one: **Googleâ€™s V8 Engine** (used in Chrome and Node.js).

### ğŸ”§ Engineâ€™s Two Core Components

1. **Memory Heap** â€“ A large unstructured memory pool for storing **objects, arrays, and functions**.

   * Think: A warehouse where data â€œlivesâ€.
2. **Call Stack** â€“ A structured â€œto-do listâ€ that tracks **which function is currently running**.

   * Think: A stack of plates â€” last in, first out (LIFO).

---

## ğŸŒ€ Two-Phase Execution Process (Secret Behind Hoisting)

1. **Creation Phase (Memory Setup):**

   * Engine scans the code first.
   * Sets up memory for **variables and functions**.
   * Variables declared with `var` â†’ initialized as **undefined**.
   * Functions â†’ full function object created in memory.
2. **Execution Phase (Running Code):**

   * The engine executes the code line-by-line.
   * Assigns values, calls functions, performs logic, etc.

ğŸ§  This two-phase system gives rise to **Hoisting**.

---

## ğŸ§© Step-by-Step Example

```js
var score = 50;
const playerName = "Alex";

function calculateBonus(currentScore) {
    var bonus = currentScore / 10;
    return bonus;
}

var finalScore = score + calculateBonus(score);
console.log(finalScore);
```

### ğŸ§¾ Step 0: Compilation (Before Running)

1. Code â†’ parsed into **Abstract Syntax Tree (AST)**.
2. AST â†’ compiled into **Bytecode**.
3. Bytecode stored in memory (**Code Space**) for fast execution.

---

### ğŸ§± Step 1: Global Creation Phase

* **Global Execution Context (GEC)** created and pushed on the **Call Stack**.
* Memory setup:

  * `score` â†’ `undefined`
  * `playerName` â†’ uninitialized (in **Temporal Dead Zone - TDZ**)
  * `calculateBonus` â†’ pointer to Function Object in Heap
  * `finalScore` â†’ `undefined`

ğŸ“¦ **Heap:** Holds function object `calculateBonus()`.

---

### âš¡ Step 2: Global Execution Phase

1. `score = 50;`
2. `playerName = "Alex";` â†’ exits TDZ.
3. `finalScore = score + calculateBonus(score);`

   * Engine pauses here â†’ calls the function.

---

### ğŸ”„ Step 3: Function Execution Context (FEC)

1. New **FEC** created for `calculateBonus(50)`.
2. Added to **top** of Call Stack.
3. Local Memory setup:

   * `currentScore = 50`
   * `bonus = undefined`
4. Execute:

   * `bonus = 50 / 10 â†’ 5`
   * `return bonus`
5. Function returns â†’ value `5` passed back to GEC.

ğŸ“œ **Stack snapshot:**

```
| calculateBonus() Context |  â† executing here
| Global Execution Context  |  â† paused
```

---

### ğŸ” Step 4: Return to Global Execution

* `finalScore = 50 + 5 â†’ 55`
* `console.log(finalScore)` â†’ creates new FEC, prints 55.
* All contexts popped from stack â†’ program ends.

---

## ğŸ” Key Takeaways

| Concept                       | Description                                           |
| ----------------------------- | ----------------------------------------------------- |
| **Compilation**               | JavaScript code converted to bytecode before running  |
| **Creation before Execution** | Memory is allocated first, then values are assigned   |
| **Call Stack**                | Manages which function is running and where to return |
| **Heap**                      | Stores actual objects/functions                       |
| **Execution Context**         | Environment for running JS code                       |

---

## ğŸª„ Hoisting Explained

### ğŸš« The Misleading Idea

> â€œJavaScript moves declarations to the top.â€ â†’ âŒ False!

### âœ… The Real Mechanism

* JS executes in **two passes**:

  1. **Creation Phase:** Memory setup (variables/functions recognized)
  2. **Execution Phase:** Code actually runs
* Hoisting = the *visible result* of this two-phase process.

---

## ğŸ Analogy: The Teacher and the Roster

**Teacher (JS Engine)** enters class (scope):

1. **Takes Attendance (Creation Phase):** Knows which students (variables/functions) exist.
2. **Teaches Lesson (Execution Phase):** Goes through code line by line.

Now, the â€œstudentsâ€ behave differently:

### ğŸ§‘â€ğŸ« Function Declarations â€” The Eager Student

```js
console.log(sayHello()); // "Hello!"
function sayHello() { return "Hello!"; }
```

âœ… Already seated with homework done â†’ fully hoisted.

### ğŸª‘ var â€” The Reserved Desk Student

```js
console.log(studentName); // undefined
var studentName = "Alice";
```

âœ… Desk reserved (declared), but student absent (undefined).

### ğŸšª let / const â€” The Late Students (Strict Rule)

```js
console.log(score); // ReferenceError
let score = 100;
```

ğŸš« Known to exist, but canâ€™t be accessed before initialization (in TDZ).

---

## ğŸ§­ Final Summary Definition

**Hoisting** is JavaScriptâ€™s behavior of knowing about variable and function declarations before execution.

| Keyword    | Hoisted? | Initialized?  | Accessible Before Line? |
| ---------- | -------- | ------------- | ----------------------- |
| `function` | âœ… Fully  | âœ…             | âœ…                       |
| `var`      | âœ…        | âŒ (undefined) | âœ…                       |
| `let`      | âœ…        | âŒ             | âŒ (TDZ)                 |
| `const`    | âœ…        | âŒ             | âŒ (TDZ)                 |

âœ¨ Remember: Nothing is â€œmovedâ€ â€” memory is simply prepared *before* running the code.

---
# JavaScript Scope, Closures & Higher-Order Functions â€” Short Notes

## ğŸ§­ Part 1: Scope â€” What Can See What?

### What is Scope?

Scope = The visibility & accessibility of variables â€” defines **where you can access a variable**.

ğŸ”¹ Think of it like rooms in a house:

* Inner rooms can look **out** (access outer variables)
* Outer rooms canâ€™t look **in** (canâ€™t access inner variables)

---

### ğŸ  1. Global Scope

Declared outside any function/block â†’ accessible everywhere.

```js
const globalVar = "I'm global";
function show() { console.log(globalVar); }
show(); // âœ…
console.log(globalVar); // âœ…
```

Analogy: Like the air outside â€” everyone can access it.

---

### ğŸ›ï¸ 2. Function Scope

Declared **inside** a function â†’ accessible **only inside** it.

```js
function myFunction() {
  const message = "Hi";
  console.log(message); // âœ…
}
myFunction();
console.log(message); // âŒ ReferenceError
```

---

### ğŸ“¦ 3. Block Scope

`let` and `const` respect block `{}` boundaries; `var` does not.

```js
if (true) {
  let a = 10;
  const b = 20;
  var c = 30;
}
console.log(a, b); // âŒ Error
console.log(c); // âœ… 30 (var leaks)
```

ğŸ”¹ `var` â†’ function-scoped only
ğŸ”¹ `let`, `const` â†’ block-scoped

---

### ğŸ§  Lexical Scope

Scope depends on **where code is written**, not called.

```js
const name = "Global";
function outer() {
  const name = "Outer";
  function inner() {
    const name = "Inner";
    console.log(name); // "Inner"
  }
  inner();
}
outer();
```

ğŸ“š JavaScript looks **outward** for variables â†’ Scope Chain:

> Inner â†’ Middle â†’ Outer â†’ Global

---

## ğŸ’« Part 2: Closures â€” Functions Remember Their Birthplace

### What is a Closure?

A **function that remembers variables** from its outer scope, even after the outer function has finished executing.

```js
function outer() {
  const message = "Hello";
  return function inner() { console.log(message); };
}
const greet = outer();
greet(); // "Hello"
```

ğŸ§© `inner` remembers `message` â€” thatâ€™s a closure!

---

### ğŸ” Private Variables Example

```js
function createBankAccount(balance) {
  return {
    deposit: amt => balance += amt,
    withdraw: amt => (amt > balance ? "Insufficient" : balance -= amt),
    getBalance: () => balance
  };
}

const acc = createBankAccount(100);
acc.deposit(50); // 150
console.log(acc.getBalance()); // 150
console.log(acc.balance); // undefined âŒ
```

Closures protect private data â€” only functions inside can access it.

---

### ğŸ§® Counter Example

```js
function createCounter() {
  let count = 0;
  return function() {
    return ++count;
  };
}
const counter = createCounter();
counter(); // 1
counter(); // 2
```

Each call â€œremembersâ€ its own `count`.

---

## âš™ï¸ Part 3: Higher-Order Functions (HOF)

### Definition

A **function that takes another function** as an argument **or returns** one.

```js
function repeat(n, action) {
  for (let i = 0; i < n; i++) action(i);
}
repeat(3, i => console.log(i));
// 0 1 2
```

---

### Example â€” Built-in HOFs

```js
const nums = [1,2,3,4];
const doubled = nums.map(num => num * 2);
console.log(doubled); // [2,4,6,8]
```

### Why â€œHigher-Orderâ€?

Because they operate **on functions**, not just values.

ğŸ“˜ Functions in JS are **first-class citizens** â€” can be passed, returned, or stored.

---

## ğŸ§© Quick Summary

| Concept           | Description                          | Example                       |
| ----------------- | ------------------------------------ | ----------------------------- |
| **Scope**         | Defines where variables are visible  | Global, Function, Block       |
| **Lexical Scope** | Scope depends on code position       | Inner â†’ Outer â†’ Global        |
| **Closure**       | Function remembers outer vars        | Private counters, data hiding |
| **HOF**           | Functions that take/return functions | map, filter, reduce           |

---

âœ¨ **In short:**

> Scope decides â€œwho can see what,â€
> Closures decide â€œwho remembers what,â€
> Higher-order functions decide â€œwho controls what.â€
---
