# JavaScript Objects — Quick Notes

## 1. What is an Object?

* An object is a **collection of key–value pairs**.
* Keys are **strings or Symbols**; values can be **any type** (number, string, array, object, etc.).

```js
const person = {
  name: "Alice",
  age: 30,
  isStudent: true
};
```

## 2. CRUD Operations

### A. Create

```js
const user = { username: "js_dev", loginCount: 57 };
```

### B. Read (Access)

* **Dot Notation:** `user.username`
* **Bracket Notation:** `user["loginCount"]`
* Use bracket notation when key has special characters or comes from a variable.

### C. Update/Add

```js
user.isPremium = true;
user.username = "pro_dev";
```

### D. Delete

```js
delete user.isPremium;
```

---

## 3. Methods & `this`

* A function inside an object = **method**.
* `this` refers to the **object itself**.

```js
const user = {
  name: "Alice",
  greet() { console.log(`Hi, I'm ${this.name}`); }
};
user.greet();
```

---

## 4. Looping Through Objects

### A. `for...in`

Iterates keys, including prototype chain (avoid).

```js
for (const key in obj) console.log(key, obj[key]);
```

### B. Modern Methods

```js
Object.keys(obj);   // [keys]
Object.values(obj); // [values]
Object.entries(obj);// [[key,value]]

for (const [k,v] of Object.entries(obj)) console.log(k,v);
```

✅ Safer & cleaner than `for...in`.

---

## 5. Reference Type

Objects store **references**, not copies.

```js
let a = {x:1}; let b=a; b.x=2; // a.x → 2
```

### Shallow Copy

```js
const copy = {...a}; // or Object.assign({}, a)
```

### Deep Copy

```js
const clone = structuredClone(a);
```

* Handles nested objects & arrays.
* ❌ Cannot clone functions or DOM nodes.

---

## 6. Destructuring

### Object Destructuring

```js
const user = {name:"Alice", email:"a@x.com", profile:{isAdmin:true}};
const {name, email} = user;
const {profile:{isAdmin}} = user;
```

### Array Destructuring

```js
const [first, second] = [10,20,30];
```

---

## 7. Symbols

* Unique, hidden keys for objects.

```js
const id = Symbol("id");
const user = { name: "Alice", [id]: 123 };
```

* Symbol keys are **not** shown in `for...in` or `Object.keys()`.
* Use `Object.getOwnPropertySymbols(obj)` to access them.

---

## 8. Summary Table

| Method                         | Use                 | Safe | Notes                    |
| ------------------------------ | ------------------- | ---- | ------------------------ |
| `for...in`                     | Iterate keys        | ❌    | Includes prototype props |
| `Object.keys`                  | Get keys            | ✅    | Own props only           |
| `Object.values`                | Get values          | ✅    | Own props only           |
| `Object.entries`               | Keys + values       | ✅    | Best modern option       |
| `structuredClone()`            | Deep copy           | ✅    | Built-in & fast          |
| `JSON.parse(JSON.stringify())` | Deep copy (simple)  | ⚠️   | Loses functions          |
| `_.cloneDeep()`                | Deep copy (complex) | ✅    | Requires lodash          |

---

**Quick Tip:** Always prefer `Object.entries()` for looping and `structuredClone()` for safe deep copying.

---
# JavaScript Functions — Quick Notes

## 🧩 Part 1: The Core Concept — What is a Function?

**A function** is a reusable “code machine” or “recipe.” It performs a task when called.

**Analogy:**

* Function = Recipe 🍞
* Parameters = Ingredients 🥪
* Return Value = Finished Dish 🍽️

### 🧠 Why Functions?

**DRY Principle (Don’t Repeat Yourself)** — Write once, reuse multiple times.

### 🔹 Core Parts

1. **Declaration** — Define the function.
2. **Calling** — Use the function.
3. **Parameters / Return Value** — Input and output.

### Example:

```js
function greet(name) {
  const message = `Hello, ${name}!`;
  return message;
}

console.log(greet("Alice")); // Hello, Alice!
```

**Parameter:** Placeholder inside function → `name`
**Argument:** Actual value passed → `"Alice"`
**Return Value:** Sent back using `return`

---

## 🧱 Part 2: Different Ways to Create Functions

### A. Function Declaration

```js
function add(a, b) {
  return a + b;
}
console.log(add(2, 3)); // 5 ✅ Works before definition (hoisted)
```

* **Hoisted** → Can be used before defined.

### B. Function Expression

```js
const subtract = function(a, b) {
  return a - b;
};
console.log(subtract(10, 5)); // 5
```

* **Not hoisted** → Must be defined before use.

### C. Arrow Function (ES6)

```js
const multiply = (a, b) => a * b;
const square = x => x * x;
```

**Implicit Return:** No `{}` or `return` needed if single expression.

**Returning Objects:** Use parentheses.

```js
const createUser = name => ({ name });
```

---

## ⚙️ Part 3: Advanced Parameter Concepts

### A. Default Parameters (ES6)

```js
function greet(name = "Guest") {
  console.log(`Hello, ${name}!`);
}
greet(); // Hello, Guest!
```

### B. Rest Parameters (...)

```js
function sumAll(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}
console.log(sumAll(1, 2, 3, 4)); // 10
```

Collects multiple arguments into an array.

---

## 🌍 Part 4: Scope — Where Do Variables Live?

```js
let globalVar = "Global";
function example() {
  let localVar = "Local";
  console.log(globalVar); // ✅
  console.log(localVar);  // ✅
}
example();
// console.log(localVar); ❌ Error
```

**Global Scope:** Accessible everywhere.
**Function Scope:** Exists only inside the function.

---

## 🧰 Rest vs Spread — Same Syntax, Opposite Meaning

| Concept    | Action | Description                     |
| ---------- | ------ | ------------------------------- |
| **Spread** | Unpack | Break apart arrays/objects      |
| **Rest**   | Pack   | Gather multiple values into one |

### 🟢 Spread Examples

```js
const arr = [1, 2, 3];
console.log(...arr); // 1 2 3

const copy = [...arr]; // Copy array
const combined = [...arr, 4, 5]; // Merge arrays

const person = { name: "Alice", age: 25 };
const updated = { ...person, city: "NYC" }; // Merge objects
```

### 🔵 Rest Examples

```js
function sum(...nums) {
  return nums.reduce((a, b) => a + b);
}
console.log(sum(1,2,3)); // 6

const [first, ...rest] = [1,2,3,4];
console.log(rest); // [3,4]

const { name, ...otherInfo } = { name:"Alice", age:25, city:"NYC" };
console.log(otherInfo); // {age:25, city:"NYC"}
```

### 🧠 Quick Rule

* **RIGHT side = Spread** → expands.
* **LEFT side = Rest** → collects.

---

## ⚡ Arrow Functions In-Depth

### 1. Why Use Them?

* Shorter syntax.
* Fixes confusing `this` behavior.

### 2. Syntax Evolution

```js
// Traditional
const add = function(a, b) { return a + b; };

// Arrow
const add = (a, b) => a + b;

// Single param
const square = x => x * x;

// Zero params
const sayHi = () => "Hi!";
```

### 3. Returning Objects

```js
const makeUser = name => ({ name });
```

---

## 🔁 Callback Functions

A **callback function** is passed into another function to be executed later.

**Analogy:** Ordering a pizza 🍕

* You order (call main function).
* Leave your phone number (callback function).
* They call you when ready (execute callback).

### Example

```js
function pickUpPizza() {
  console.log("Pizza is ready! 🍕");
}

function orderPizza(callback) {
  console.log("Placing the pizza order...");
  console.log("Pizza is cooked!");
  callback(); // Calls the function you passed
}

orderPizza(pickUpPizza);
console.log("I'm at home coding while pizza cooks.");
```

**Output:**

```
Placing the pizza order...
Pizza is cooked!
Pizza is ready! 🍕
```

---

### ✅ Quick Summary

| Concept        | Meaning                  | Example                      |
| -------------- | ------------------------ | ---------------------------- |
| Function       | Reusable block           | `function greet(){}`         |
| Expression     | Stored in var            | `const greet = function(){}` |
| Arrow Function | Short syntax             | `const greet = () => {}`     |
| Default Param  | Fallback value           | `(name = "Guest")`           |
| Rest Param     | Collect args             | `(...args)`                  |
| Spread         | Expand array/object      | `(...arr)`                   |
| Callback       | Function inside function | `orderPizza(pickUpPizza)`    |

---

# JavaScript Engine & Execution Flow — The Complete Picture

## 💡 The Fundamental Problem: Computers Are Not Smart

* The CPU doesn’t understand JavaScript — it only understands **Machine Code (1s and 0s)**.
* JavaScript must be **translated into machine instructions** — this is done by the **JavaScript Engine**.

## ⚙️ The JavaScript Engine

* A program that **reads, compiles, and executes** JS code.
* The most popular one: **Google’s V8 Engine** (used in Chrome and Node.js).

### 🔧 Engine’s Two Core Components

1. **Memory Heap** – A large unstructured memory pool for storing **objects, arrays, and functions**.

   * Think: A warehouse where data “lives”.
2. **Call Stack** – A structured “to-do list” that tracks **which function is currently running**.

   * Think: A stack of plates — last in, first out (LIFO).

---

## 🌀 Two-Phase Execution Process (Secret Behind Hoisting)

1. **Creation Phase (Memory Setup):**

   * Engine scans the code first.
   * Sets up memory for **variables and functions**.
   * Variables declared with `var` → initialized as **undefined**.
   * Functions → full function object created in memory.
2. **Execution Phase (Running Code):**

   * The engine executes the code line-by-line.
   * Assigns values, calls functions, performs logic, etc.

🧠 This two-phase system gives rise to **Hoisting**.

---

## 🧩 Step-by-Step Example

```js
var score = 50;
const playerName = "Alex";

function calculateBonus(currentScore) {
    var bonus = currentScore / 10;
    return bonus;
}

var finalScore = score + calculateBonus(score);
console.log(finalScore);
```

### 🧾 Step 0: Compilation (Before Running)

1. Code → parsed into **Abstract Syntax Tree (AST)**.
2. AST → compiled into **Bytecode**.
3. Bytecode stored in memory (**Code Space**) for fast execution.

---

### 🧱 Step 1: Global Creation Phase

* **Global Execution Context (GEC)** created and pushed on the **Call Stack**.
* Memory setup:

  * `score` → `undefined`
  * `playerName` → uninitialized (in **Temporal Dead Zone - TDZ**)
  * `calculateBonus` → pointer to Function Object in Heap
  * `finalScore` → `undefined`

📦 **Heap:** Holds function object `calculateBonus()`.

---

### ⚡ Step 2: Global Execution Phase

1. `score = 50;`
2. `playerName = "Alex";` → exits TDZ.
3. `finalScore = score + calculateBonus(score);`

   * Engine pauses here → calls the function.

---

### 🔄 Step 3: Function Execution Context (FEC)

1. New **FEC** created for `calculateBonus(50)`.
2. Added to **top** of Call Stack.
3. Local Memory setup:

   * `currentScore = 50`
   * `bonus = undefined`
4. Execute:

   * `bonus = 50 / 10 → 5`
   * `return bonus`
5. Function returns → value `5` passed back to GEC.

📜 **Stack snapshot:**

```
| calculateBonus() Context |  ← executing here
| Global Execution Context  |  ← paused
```

---

### 🔁 Step 4: Return to Global Execution

* `finalScore = 50 + 5 → 55`
* `console.log(finalScore)` → creates new FEC, prints 55.
* All contexts popped from stack → program ends.

---

## 🔍 Key Takeaways

| Concept                       | Description                                           |
| ----------------------------- | ----------------------------------------------------- |
| **Compilation**               | JavaScript code converted to bytecode before running  |
| **Creation before Execution** | Memory is allocated first, then values are assigned   |
| **Call Stack**                | Manages which function is running and where to return |
| **Heap**                      | Stores actual objects/functions                       |
| **Execution Context**         | Environment for running JS code                       |

---

## 🪄 Hoisting Explained

### 🚫 The Misleading Idea

> “JavaScript moves declarations to the top.” → ❌ False!

### ✅ The Real Mechanism

* JS executes in **two passes**:

  1. **Creation Phase:** Memory setup (variables/functions recognized)
  2. **Execution Phase:** Code actually runs
* Hoisting = the *visible result* of this two-phase process.

---

## 🍎 Analogy: The Teacher and the Roster

**Teacher (JS Engine)** enters class (scope):

1. **Takes Attendance (Creation Phase):** Knows which students (variables/functions) exist.
2. **Teaches Lesson (Execution Phase):** Goes through code line by line.

Now, the “students” behave differently:

### 🧑‍🏫 Function Declarations — The Eager Student

```js
console.log(sayHello()); // "Hello!"
function sayHello() { return "Hello!"; }
```

✅ Already seated with homework done → fully hoisted.

### 🪑 var — The Reserved Desk Student

```js
console.log(studentName); // undefined
var studentName = "Alice";
```

✅ Desk reserved (declared), but student absent (undefined).

### 🚪 let / const — The Late Students (Strict Rule)

```js
console.log(score); // ReferenceError
let score = 100;
```

🚫 Known to exist, but can’t be accessed before initialization (in TDZ).

---

## 🧭 Final Summary Definition

**Hoisting** is JavaScript’s behavior of knowing about variable and function declarations before execution.

| Keyword    | Hoisted? | Initialized?  | Accessible Before Line? |
| ---------- | -------- | ------------- | ----------------------- |
| `function` | ✅ Fully  | ✅             | ✅                       |
| `var`      | ✅        | ❌ (undefined) | ✅                       |
| `let`      | ✅        | ❌             | ❌ (TDZ)                 |
| `const`    | ✅        | ❌             | ❌ (TDZ)                 |

✨ Remember: Nothing is “moved” — memory is simply prepared *before* running the code.

---
# JavaScript Scope, Closures & Higher-Order Functions — Short Notes

## 🧭 Part 1: Scope — What Can See What?

### What is Scope?

Scope = The visibility & accessibility of variables — defines **where you can access a variable**.

🔹 Think of it like rooms in a house:

* Inner rooms can look **out** (access outer variables)
* Outer rooms can’t look **in** (can’t access inner variables)

---

### 🏠 1. Global Scope

Declared outside any function/block → accessible everywhere.

```js
const globalVar = "I'm global";
function show() { console.log(globalVar); }
show(); // ✅
console.log(globalVar); // ✅
```

Analogy: Like the air outside — everyone can access it.

---

### 🛏️ 2. Function Scope

Declared **inside** a function → accessible **only inside** it.

```js
function myFunction() {
  const message = "Hi";
  console.log(message); // ✅
}
myFunction();
console.log(message); // ❌ ReferenceError
```

---

### 📦 3. Block Scope

`let` and `const` respect block `{}` boundaries; `var` does not.

```js
if (true) {
  let a = 10;
  const b = 20;
  var c = 30;
}
console.log(a, b); // ❌ Error
console.log(c); // ✅ 30 (var leaks)
```

🔹 `var` → function-scoped only
🔹 `let`, `const` → block-scoped

---

### 🧠 Lexical Scope

Scope depends on **where code is written**, not called.

```js
const name = "Global";
function outer() {
  const name = "Outer";
  function inner() {
    const name = "Inner";
    console.log(name); // "Inner"
  }
  inner();
}
outer();
```

📚 JavaScript looks **outward** for variables → Scope Chain:

> Inner → Middle → Outer → Global

---

## 💫 Part 2: Closures — Functions Remember Their Birthplace

### What is a Closure?

A **function that remembers variables** from its outer scope, even after the outer function has finished executing.

```js
function outer() {
  const message = "Hello";
  return function inner() { console.log(message); };
}
const greet = outer();
greet(); // "Hello"
```

🧩 `inner` remembers `message` — that’s a closure!

---

### 🔐 Private Variables Example

```js
function createBankAccount(balance) {
  return {
    deposit: amt => balance += amt,
    withdraw: amt => (amt > balance ? "Insufficient" : balance -= amt),
    getBalance: () => balance
  };
}

const acc = createBankAccount(100);
acc.deposit(50); // 150
console.log(acc.getBalance()); // 150
console.log(acc.balance); // undefined ❌
```

Closures protect private data — only functions inside can access it.

---

### 🧮 Counter Example

```js
function createCounter() {
  let count = 0;
  return function() {
    return ++count;
  };
}
const counter = createCounter();
counter(); // 1
counter(); // 2
```

Each call “remembers” its own `count`.

---

## ⚙️ Part 3: Higher-Order Functions (HOF)

### Definition

A **function that takes another function** as an argument **or returns** one.

```js
function repeat(n, action) {
  for (let i = 0; i < n; i++) action(i);
}
repeat(3, i => console.log(i));
// 0 1 2
```

---

### Example — Built-in HOFs

```js
const nums = [1,2,3,4];
const doubled = nums.map(num => num * 2);
console.log(doubled); // [2,4,6,8]
```

### Why “Higher-Order”?

Because they operate **on functions**, not just values.

📘 Functions in JS are **first-class citizens** — can be passed, returned, or stored.

---

## 🧩 Quick Summary

| Concept           | Description                          | Example                       |
| ----------------- | ------------------------------------ | ----------------------------- |
| **Scope**         | Defines where variables are visible  | Global, Function, Block       |
| **Lexical Scope** | Scope depends on code position       | Inner → Outer → Global        |
| **Closure**       | Function remembers outer vars        | Private counters, data hiding |
| **HOF**           | Functions that take/return functions | map, filter, reduce           |

---

✨ **In short:**

> Scope decides “who can see what,”
> Closures decide “who remembers what,”
> Higher-order functions decide “who controls what.”
---
