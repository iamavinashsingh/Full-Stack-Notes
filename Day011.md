# CSS Notes

## What is CSS?

**CSS** = Cascading Style Sheets  
It makes websites look **pretty** (colors, fonts, layouts)

- **Main Idea**: HTML handles content, **CSS handles appearance**

---

## Why We Need CSS

Without CSS:

- Websites looked plain and boring  
- Had to style each element individually  
- Code was messy and hard to maintain  

---

## How to Add CSS

### 1. Inline CSS (For one element)

```html
<h1 style="color: blue;">Blue Heading</h1>
```

### 2. Internal CSS (For one page)

```html
<style>
  h1 { color: blue; }
</style>
```

### 3. External CSS (Best for whole website)

```html
<link rel="stylesheet" href="styles.css">
```

---

## CSS Building Blocks

```css
selector {
  property: value;
}
```

- **Selector**: Who to style (like `h1`)
- **Property**: What to change (like `color`)
- **Value**: How to change it (like `blue`)

---

## 4 Main Selectors

### 1. Element Selector

Styles all elements of that type

```css
p {
  color: gray;
}
```

### 2. Class Selector (Most common)

Styles elements with that class

```css
.warning {
  color: red;
}
```

```html
<p class="warning">This is red</p>
```

### 3. ID Selector

Styles one specific element

```css
#header {
  background: blue;
}
```

```html
<header id="header">...</header>
```

### 4. Group Selector

Styles multiple elements at once

```css
h1, h2, h3 {
  font-family: Arial;
}
```

---

## Colors in CSS

### 1. Color Names (Easiest)

```css
color: red;
color: lightblue;
```

### 2. Hex Codes (Most common)

```css
color: #FF0000;    /* Red */
color: #0000FF;    /* Blue */
color: #000000;    /* Black */
color: #FFFFFF;    /* White */
```

### 3. RGB (Red, Green, Blue)

```css
color: rgb(255, 0, 0);        /* Red */
color: rgba(255, 0, 0, 0.5);  /* See-through red */
```

### 4. HSL (Hue, Saturation, Lightness)

```css
color: hsl(0, 100%, 50%);       /* Red */
color: hsla(0, 100%, 50%, 0.5); /* See-through red */
```

---

## Text Styling

### Font Family

```css
body {
  font-family: Arial, sans-serif;
}
```

### Font Size

```css
p {
  font-size: 16px;    /* Fixed size */
  font-size: 1rem;    /* Responsive size */
}
```

### Font Weight

```css
h1 {
  font-weight: bold;    /* or 700 */
}

.light-text {
  font-weight: 300;     /* Thin text */
}
```

### Font Style

```css
.italic {
  font-style: italic;
}
```

### Shortcut Method

```css
p {
  font: italic bold 1rem Arial, sans-serif;
}
```

---

## Size Units

### Percentage (%)

Relative to parent element

```css
.sidebar {
  width: 25%; /* 25% of parent's width */
}
```

### Viewport Units

Relative to screen size

```css
.hero {
  width: 100vw; /* Full screen width */
  height: 100vh; /* Full screen height */
}
```

---
# CSS Box Model & Display Properties: The Simplest Explanation

## Everything is a Box

Your browser sees every element on a webpage as a rectangular **box** ‚Äî even circles are just boxes with rounded corners!

---

## The 4 Layers of a Box

Every box has 4 layers (from **inside out**):

1. **Content** ‚Äì Your text or image  
2. **Padding** ‚Äì Space **inside** the box (like the mat in a picture frame)  
3. **Border** ‚Äì The **edge** of the box (like the picture frame itself)  
4. **Margin** ‚Äì Space **outside** the box (personal space between frames)

![Box Model](https://miro.medium.com/v2/resize:fit:720/format:webp/1*2yX9m4SSw6Gxdx0g10fffg.png)

---

## Controlling Box Size

- `width` & `height`: Set content size  
- `max-width`: ‚ÄúGrow up to this size but no more‚Äù (great for responsive design)

### Example:

```css
.container {
  width: 100%;        /* Fill container */
  max-width: 800px;   /* But never wider than 800px */
}
```

---

## Spacing: Padding & Margin

### Padding (Inside Space)

```css
/* All sides same */
padding: 10px;

/* Top/Bottom = 10px, Left/Right = 20px */
padding: 10px 20px;

/* Top=10px, Right=20px, Bottom=30px, Left=40px */
padding: 10px 20px 30px 40px;
```

### Margin (Outside Space)

Uses the same shorthand as padding:

```css
margin: 10px;
margin: 10px 20px;
margin: 10px 20px 30px 40px;
```

---

## Borders

Borders have 3 properties:

- `border-width`: How thick  
- `border-style`: `solid`, `dotted`, `dashed`, etc.  
- `border-color`: Color of border

### Shorthand:

```css
border: 2px solid black;
```

---

## Rounded Corners

```css
border-radius: 10px; /* All corners */
border-radius: 10px 5px 10px 5px; /* TL, TR, BR, BL */
```

---

## The Box-Sizing Miracle

By default, when you set `width: 300px`, the browser adds padding and border **on top** of that, making the element **wider** than 300px.

### Fix this with one magic rule:

```css
* {
  box-sizing: border-box;
}
```

This makes `width: 300px` include **padding and border**, which is much more intuitive!

---

## How Elements Flow: Block vs. Inline

### Block Elements (like paragraphs)

- Start on a **new line**
- Take **full available width**
- Stack **vertically**

**Examples**: `<div>`, `<p>`, `<h1>`‚Äì`<h6>`, `<section>`

---

### Inline Elements (like words)

- Stay in the **same line**
- Take only **needed width**
- Flow **horizontally**

**Examples**: `<span>`, `<a>`, `<strong>`, `<em>`

---

## Changing Behavior with `display` Property

You can change how elements behave:

```css
/* Make inline element behave like block */
a {
  display: block;
}

/* Make block elements sit side-by-side */
li {
  display: inline;
}

/* Best of both: sits inline but respects width/height */
button {
  display: inline-block;
}

/* Hide element completely */
.hidden {
  display: none;
}
```

---

## Block vs. Inline: Quick Comparison

| Feature               | Block ‚úÖ     | Inline ‚ùå    |
|-----------------------|--------------|--------------|
| Starts new line       | ‚úÖ Yes        | ‚ùå No         |
| Width                 | Full container | Only needed |
| Height                | Respects height | Ignores height |
| Margin (top/bottom)   | ‚úÖ Works      | ‚ùå Ignored   |
| Margin (left/right)   | ‚úÖ Works      | ‚úÖ Works     |
| Padding (top/bottom)  | ‚úÖ Works      | ‚úÖ Visual only |
| Padding (left/right)  | ‚úÖ Works      | ‚úÖ Works     |

---

## üîë Key Takeaways

- Everything is a box ‚Äì browsers see rectangles everywhere  
- Use `box-sizing: border-box` ‚Äì makes sizing predictable  
- `Padding` = inside space, `Margin` = outside space  
- Block elements **stack**, Inline elements **flow**  
- Use the `display` property to change element behavior

---

# Lecture 03: Cascading and position

### The CSS Cascade - The Ultimate Rulebook for Style Conflicts

**The First Principle:** A web browser is a machine that needs a strict, unambiguous set of rules to operate. When multiple CSS rules try to style the same element, the browser cannot "guess" which one to use. It must follow a predictable hierarchy to determine a single winner. This hierarchy is called the **Cascade**.

Think of it as a series of tie-breaker rounds. If there's a winner in an early round, the later rounds are ignored.

---

### Rule 1: !important - The "Emergency Override"

- **The Problem:** What if you have a very complex website, and a specific style (perhaps from an external library or a very generic rule) is overriding a style you desperately need to apply? You need an "emergency escape hatch" to break all the normal rules and force a style to win.
- **The Logical Solution:** Create a special keyword that elevates a single style declaration to the highest possible level of importance. This is the **!important** flag.
- **How it Works:** When you add !important to a style declaration, it jumps to the front of the line, beating inline styles, IDs, classes, and everything else. It is the most powerful tool in the Cascade.
- **Mini Example:** code Html code CSS
    
    ```html
    <p id="special-text" style="color: blue;">This is some text.</p>
    ```
    
    ```css
    /* This ID is very specific, but the !important rule will beat it. */
    #special-text {
        color: green !important; /* WINS */
    }
    p {
        color: red;
    }
    ```
    
    - **Result:** The text will be **green**. The !important flag overrules both the inline style and the ID selector.
- **Warning to Students:** Using !important is like using a sledgehammer to crack a nut. It's a sign that your CSS specificity is messy. Avoid it in your own code whenever possible. Use it only as a last resort to override styles you don't control (like from a third-party framework).

---

### Rule 2: Inline CSS (style attribute) - "The Closest Style"

- **The Problem:** How can we apply a unique style to one, and only one, specific element without having to create a new ID or class in our stylesheet? We need a way to attach a style directly to the element itself.
- **The Logical Solution:** Allow a style attribute to be placed directly inside an HTML tag. Because this style is physically attached to the element, it is considered more specific and powerful than any rule coming from an external or internal stylesheet (unless that rule uses !important).
- **How it Works:** The browser considers styles in the style attribute to have a higher priority than styles defined in <style> tags or linked .css files.
- **Mini Example:** code Html code CSS code Html
    
    
    ```html
    <p id="intro-paragraph">This is the introduction.</p>
    ```
    
    ```css
    /* styles.css */
    #intro-paragraph {
        color: blue;
    }
    ```
    
    Now, let's add an inline style to the HTML:
    
    ```html
    <p id="intro-paragraph" style="color: red;">This is the introduction.</p> <!-- WINS -->
    ```
    
    - **Result:** The text will be **red**. The inline style is "closer" to the element and therefore wins against the ID selector from the stylesheet.

---

### Rule 3: ID Selector (#) - "The Unique Identifier"

- **The Problem:** We need a way to target one single, unique element on a page with a powerful and specific rule. This is for major layout components like a site header, a main content block, or a footer.
- **The Logical Solution:** Create an id attribute, which must be unique per page. In CSS, create a corresponding selector (#) that has a very high specificity score.
- **How it Works:** An ID selector will always beat a class selector, an element selector, or any combination of them.
- **Mini Example:** code Html code CSS
    
    ```html
    <div id="sidebar" class="box">...</div>
    ```
    
    ```css
    #sidebar {
        background-color: lightgray; /* WINS */
    }
    .box {
        background-color: lightblue;
    }
    div {
        background-color: coral;
    }
    ```
    
    - **Result:** The div's background will be **lightgray**. The ID selector (#sidebar) is more specific than the class selector (.box) and the element selector (div).

---

### Rule 4: Class Selector (.) - "The Reusable Group"

- **The Problem:** We need a way to apply the same style to many different elements, regardless of their tag type or position. We need a reusable "label."
- **The Logical Solution:** Create the class attribute. In CSS, the class selector (.) is more specific than a general element selector but less specific than a unique ID.
- **How it Works:** It beats element selectors but loses to ID selectors.
- **Mini Example:** code Html code CSS
    
    
    ```html
    <h2 class="warning">Warning Title</h2>
    <p>This is a paragraph.</p>
    ```
    
    ```css
    .warning {
        color: orange; /* WINS */
    }
    h2 {
        color: black;
    }
    ```
    
    - **Result:** The <h2> text will be **orange**. The class selector (.warning) is more specific than the element selector (h2). The paragraph will remain its default color.

---

### Rule 5: Element Selector (p, h1, etc.) - "The General Rule"

- **The Problem:** We need a way to set broad, default styles for all elements of a certain type across our entire site.
- **The Logical Solution:** Create selectors that target the HTML tags themselves. This is the least specific type of selector.
- **How it Works:** An element selector provides a baseline style. It will be overridden by any class, ID, inline style, or !important rule that also targets that element.
- **Mini Example:** code Html code CSS
    
    
    ```html
    <p>A standard paragraph.</p>
    <p class="highlight">A highlighted paragraph.</p>
    ```
    
    ```css
    .highlight {
        background-color: yellow;
    }
    p {
        background-color: lightgray; /* Loses to .highlight */
    }
    ```
    
    - **Result:** The first paragraph will have a **light gray** background. The second paragraph will have a **yellow** background because the more specific .highlight class selector overrides the general p element selector.

---

### Rule 6: Position / Source Order - "The Final Tie-Breaker"

- **The Problem:** What happens if two rules have the *exact same level of importance and specificity*? The browser still needs a way to break the tie.
- **The Logical Solution:** The simplest rule of all: **the last one defined wins.**
- **How it Works:** The browser reads your CSS file(s) from top to bottom. If it finds two identical rules, it will apply the one it read most recently.
- **Mini Example:** code Html code CSS
    
    
    ```html
    <p class="featured-text important-text">Some text.</p>
    ```
    
    ```css
    /* styles.css */
    
    /* Both are class selectors, so they have the same specificity. */
    .featured-text {
        color: blue;
    }
    
    .important-text {
        color: red; /* WINS because it's defined last */
    }
    ```
    
    - **Result:** The text will be **red**. Both selectors are classes (equal specificity), so the one that comes last in the stylesheet wins the tie.

## The First Principle: The Normal Document Flow

The most fundamental truth is that by default, every element on a webpage exists in the **Normal Document Flow**. This is the system where block elements stack vertically on top of each other, and inline elements flow horizontally next to each other. They respect each other's space and don't overlap.

The position property is the tool we use to **remove an element from this normal flow** and give it special positioning rules.

---

### 1. position: static; (The Default)

- **The First Principle:** Every element needs a default positioning behavior.
- **What it means:** "This element should behave completely normally."
- **How it works:** This is the default value for every single element. An element with position: static is not "positioned" in a special way. It simply exists in the normal document flow.
- **The Critical Rule:** The positioning properties top, right, bottom, left, and z-index have **absolutely no effect** on a static element. They are ignored.
- **When to use it:** You almost never explicitly write position: static;. You use it primarily to *undo* a different position value. For example, you might have an element that is position: fixed on desktop but you want to return it to normal flow on mobile, so you'd set it to position: static in a media query.

---

### 2. position: relative; (The "Stomping Ground")

- **The First Principle:** We need a way to slightly adjust an element's position *without* disrupting the layout of the elements around it. We also need a way to create a "positioning context" for other, more advanced elements.
- **What it means:** "This element is now a candidate for being moved, and it will also become a positioning anchor for its children."
- **How it works (Two Key Behaviors):**
    1. **It can be moved:** Once you set position: relative;, you can now use the properties top, right, bottom, and left to nudge it from its original spot. For example, top: 20px; will move it **20px down** from where it *would have been*. left: 30px; will move it **30px to the right**.
    2. **It preserves its original space:** This is the most important part. Even after you move the element, the space it *would have occupied* in the normal flow is **still reserved for it**. The other elements on the page are not affected and do not reflow to fill the gap.
- **The Most Important Use Case (The Anchor):** A relative element becomes the **positioning context** for any of its descendant elements that are position: absolute. This is the single most common and important use of position: relative. We will see this in the next section.
- **Mini Example:** code Html code CSS
    
    ```html
    <div class="box static-box">Static</div>
    <div class="box relative-box">Relative</div>
    <div class="box static-box">Static</div>
    ```
    
    ```css
    .relative-box {
      position: relative;
      top: 20px;
      left: 20px;
      background-color: lightblue;
    }
    ```
    
    - **Result:** The blue "Relative" box will be shifted 20px down and 20px right, and it will overlap the other static boxes. However, a large empty gap will be left where it *should have been*, because its original space is preserved.

---

### 3. position: absolute; (The "Free Spirit")

- **The First Principle:** We need a way to completely remove an element from the normal document flow and position it precisely relative to an ancestor element.
- **What it means:** "This element is now a free-floating layer. Ignore all its siblings and position it according to its nearest 'positioned' ancestor."
- **How it works:**
    1. **Removed from the Flow:** The element is completely removed from the normal flow. The space it occupied vanishes, and other elements will reflow to fill that gap as if it never existed.
    2. **Finds its Anchor:** The element will look up its family tree (its parent, its grandparent, etc.) for the **nearest ancestor that has a position value other than static** (i.e., relative, absolute, fixed, or sticky).
    3. **Positions Itself:** It will then use the top, right, bottom, and left properties to position itself relative to the *padding edge* of that "positioned" ancestor.
    4. **The Fallback:** If it finds no positioned ancestor, it will position itself relative to the initial containing block, which is usually the <body> or <html> element (the viewport).
- **The "Relative-Absolute" Pattern (CRITICAL):** code Html code CSS
    
    The most common design pattern in all of CSS is to create a wrapper <div> with position: relative; and then place a child <div> inside it with position: absolute;.
    
    ```html
    <div class="card-container"> <!-- The Anchor -->
      <div class="badge">New!</div> <!-- The Free Spirit -->
    </div>
    ```
    
    ```css
    .card-container {
      position: relative; /* BECOMES THE ANCHOR */
      width: 200px;
      height: 200px;
      border: 1px solid black;
    }
    .badge {
      position: absolute; /* REMOVED FROM FLOW */
      top: 10px;          /* 10px from the top of card-container */
      right: 10px;        /* 10px from the right of card-container */
      background-color: red;
      color: white;
    }
    ```
    
    - **Result:** A "New!" badge is perfectly positioned in the top-right corner of its parent card, regardless of where that card is on the page.

---

### 4. position: fixed; (The "Stuck to the Screen")

- **The First Principle:** We need a way to position an element relative to the **browser window itself**, and make it stay there even when the user scrolls the page.
- **What it means:** "This element is now glued to the screen (the viewport)."
- **How it works:**
    1. **Removed from the Flow:** Just like absolute, the element is completely removed from the normal document flow, and the space it occupied vanishes.
    2. **Positions Itself Relative to the Viewport:** It **always** uses the browser window as its positioning context. The top, right, bottom, and left properties position it relative to the edges of the screen.
    3. **Ignores Scrolling:** The element does not move when the user scrolls the page.
- **Common Use Cases:**
    - "Stuck" navigation bars at the top of the screen (top: 0; left: 0;).
    - "Back to Top" buttons (bottom: 20px; right: 20px;).
    - Cookie consent banners.
- **Mini Example:** code CSS
    
    ```css
    .main-nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%; /* Important to set a width! */
      background-color: white;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    ```
    
    - **Result:** A navigation bar that is permanently fixed to the top of the browser window.

---

### 5. position: sticky; (The "Hybrid")

- **The First Principle:** fixed is useful, but what if we want an element to behave normally *until* it hits a certain point, and *then* become fixed?
- **What it means:** "Behave like relative until you are scrolled past a certain point, then behave like fixed."
- **How it works:**
    1. **Starts as Relative:** The element starts in the normal document flow, behaving like a position: relative element. It scrolls with the page.
    2. **The Threshold:** You must provide a threshold with top, right, bottom, or left. For example, top: 0;.
    3. **Becomes Fixed:** As the user scrolls down, the moment the top of the sticky element is about to be scrolled *off the top of the viewport*, it "sticks" to that top: 0; position and behaves like position: fixed.
    4. **Becomes Relative Again:** If the user scrolls back up past that point, it "un-sticks" and returns to its normal position in the flow.
- **Common Use Cases:**
    - Section headings in a long article that stick to the top as you scroll through that section.
    - Sidebars in a blog layout.
    - Table headers (<thead>) in a long, scrollable table.
- **Mini Example:** code Html code CSS
    
    
    ```html
    <div class="content">...</div>
    <h2 class="sticky-header">Section 1</h2>
    <div class="section-content">...long content...</div>
    <h2 class="sticky-header">Section 2</h2>
    <div class="section-content">...long content...</div>
    ```
    
    ```css
    .sticky-header {
      position: sticky;
      top: 0; /* The threshold */
      background-color: white;
    }
    ```
    
    - **Result:** As you scroll, the "Section 1" header will scroll normally until it hits the very top of the window. It will then stick there as you scroll through its content. Once the "Section 2" header scrolls up to meet it, it will "push" the first header off the screen and take its place.
